#!/usr/bin/env python
"""
Raffaello is a command line (CLI) output colorizer

Usage:
    raffaello <arguments> --- command [arguments]

    $./raffaello "pattern1=>colorA" "pattern2=>colorB" "pattern3=>colorA" ... --- command [arguments]
    $ ./raffaello file=/path/to/config/file --- command [arguments]

    e.g.

        $ ./raffaello '.*[Ee]rror.*=>red' --- dmesg    # this will highlight lines with error messages (if any) in red
        $ ./raffaello --file=dmesg.cfg --- dmesg

        $ cat dmesg.cfg
            # Dmesg config file example. Comment lines will be ignored
            .*[Ee]rror.*=>red_bold
            .*ERROR.*=>red_bold
            timed\sout=>red
            .*[Ww]arning.*=>yellow
Notes:
    1. no spaces are allowed at both sides of => sign
        error => red        WRONG
        error=> red        WRONG
        error =>red        WRONG
        error=>red        OK
    2. if a pattern contains spaces, they must be defined using "\s" symbol, for example:
        could not=>red_bold    WRONG
        could\snot=>red_bold    OK
"""

import sys
import os
import re

import logging
level = logging.DEBUG
logging.basicConfig(level=level, format='    %(levelname)s %(message)s');
log = logging.getLogger(__name__)

# Separator between Raffaello configuration and
# command to execute
command_separator = '---'

# Separator between pattern and color code
pattern_separator = '=>'

def usage():
    print(__doc__)

def help():
    usage()
    log.info('Available color list. NOTE that some colors could be unsupported on your terminal.\n')
    print(sorted(color_filters.keys()))

# [ COLOR CODES]
color_codes = {
    'black'            : chr(27)+'[30m',
    'red'            : chr(27)+'[31m',
    'green'            : chr(27)+'[32m',
    'brown'            : chr(27)+'[33m',
    'blue'            : chr(27)+'[34m',
    'purple'        : chr(27)+'[35m',
    'cyan'            : chr(27)+'[36m',
    'light_grey'    : chr(27)+'[37m',
    'dark_grey'        : chr(27)+'[30m',
    'light_red'        : chr(27)+'[31m',
    'light_green'    : chr(27)+'[32m',
    'yellow'        : chr(27)+'[33m',
    'light_blue'    : chr(27)+'[34m',
    'light_purple'    : chr(27)+'[35m',
    'light_cyan'    : chr(27)+'[36m',
    'white'            : chr(27)+'[37m'
}
end_color = chr(27)+'[39m'

# [ STYLE CODES ]
style_codes = {
    'bold' : chr(27) + '[1m',
}
end_bold = chr(27) + '[22m'


class Filter(object):
    """
    Encapsulate open and close tag codes
    """
    def __init__(self, name, open_code, close_code):
        self.__name = name
        self.open = open_code
        self.close = close_code

    def apply(self, line, matches):
        '''
        Apply filter to all matches in line
        '''
        for match in matches:
            replacement = '%s%s%s' % (self.open, match, self.close)
            line = line.replace(match, replacement)

        return line


    def __repr__(self):
        return self.__name


# [ FILTERS ]
color_filters = {}
for key, color_code in color_codes.items():
    color_filter = Filter(key, color_code, end_color)
    color_filters.update({key : color_filter})

    # bold version
    color_filter = Filter(key, '%s%s' % (color_code, style_codes['bold']),
                            end_bold + end_color)
    color_filters.update({'%s_bold' % key : color_filter})


def get_options(optargs):
    """
    Parse command-line options
    """
    global pattern_separator

    arguments_line = ' '.join(optargs)

    if '-h' in arguments_line or '--help' in arguments_line:
        help()
        sys.exit(0)

    if not command_separator in arguments_line:
        log.error('Missing separator "%s" between raffaello\
 configuration and command to execute' % command_separator)
        usage()
        sys.exit(1)

    if not pattern_separator in arguments_line\
            and not 'file' in arguments_line:
        log.error("Ill-formatted raffaello's options")
        usage()
        sys.exit(1)

    options = arguments_line.split(command_separator)[0]
    command = arguments_line.split(command_separator)[1]

    pattern_sep_option = None
    if '--sep' in options or '-s' in options:
        pattern_sep_option = re.findall("-s=.", options)
        if not pattern_sep_option:
            pattern_sep_option = re.findall("--sep=.", options)

    if pattern_sep_option:
        pattern_separator = pattern_sep_option[0].split('=')[1]
        log.debug("Changed pattern_separator in %s" % pattern_separator)
        options = options.split(' ')[1:]
        log.debug('Remaining options: {0}'.format(options))

    patterns = {}

    if '--file' in options or '-f' in options:
        config_file_path = options.split('=')[1].rstrip()
        patterns = parse_config_file(config_file_path)
    else:
        patterns = parse_color_option(options)

    return (patterns, command)



def parse_color_option(color_options):
    """
    A color option is a string in the form
    pattern=>color. No space is allowed at both sides
    of the double equal (=>) sign.
    """

    patterns = {}

    for option in color_options.split(' '):

        if len(re.findall(pattern_separator, option)) > 1:
            log.error('[Error] Can not parse option %s. Too many pattern_separator symbols (%s) in option' % (option, pattern_separator))
            sys.exit(1)
        try:
            pattern, color = option.split(pattern_separator)
        except ValueError as err:
            log.error("Could not parse option. (%s)" % err)
            log.debug("option: {0}".format(option))
            log.debug("pattern_separator: {0}".format(pattern_separator))
            sys.exit(1)

        # Remove initial quote if any
        matches = re.findall("^'", pattern)
        if matches:
            pattern = pattern[1:]

        # Remove final quote if any
        matches = re.findall("'$", pattern)
        if matches:
            pattern = pattern[:len(pattern) - 1]

        if color in color_filters:
            patterns.update( {r'%s' % pattern : color_filters[color]} )
        else:
            log.error('Color "%s" does not exist' % color)
            sys.exit(1)

    return patterns



def parse_config_file(path):
    """
    Get Pattern/Color pairs from configuration file
    """

    print(os.getcwd())
    epath = os.path.expanduser(path)
    if not os.path.exists(epath):
        log.error('Could not find config file "%s"' % path)
        sys.exit(1)

    log.debug('Reading config file %s' % epath)
    config = open(epath).readlines()
    patterns = {}
    for line in config:
        line = line.rstrip()

        if len(line) == 0 or line[0] == '#':    # skip empty lines and comments
            continue

        new_pattern = parse_color_option(line)

        patterns.update(new_pattern)

    return patterns


def paint(line):
    """
    Highlight line according to the given
    pattern/color dictionary
    """
    for pattern, filter in patterns.items():
        try:
            matches = re.findall(pattern, line)
        except Exception as err:
            log.error('%s' % err)
            log.debug('pattern: %s' % pattern)
            log.debug('line: %s' % line)
            sys.exit(1)

        line = filter.apply(line, matches)
    return line.rstrip()


def main(command):
    pipe_read, pipe_write = os.pipe()

    proc_id = os.fork()

    # child process executes the given command,
    #    parent process parses its output
    if proc_id:
        # run the provided command
        os.close(pipe_read)

        # redirect stdout to pipe
        os.dup2(pipe_write, sys.stdout.fileno())
        os.dup2(pipe_write, sys.stderr.fileno())

        os.system(command)

    else:
        # read and modify command output
        os.close(pipe_write)
        fd_read = os.fdopen(pipe_read)

        while True:
            try:
                line = fd_read.readline()

                if line:
                    print(paint(line))
                else:
                    break
            except KeyboardInterrupt:
                pass
        os._exit(os.EX_OK)

    return 0



if __name__ == '__main__':
    if len(sys.argv) < 2:
        usage()
        sys.exit(1)
    patterns, command = get_options(sys.argv[1:])
    sys.exit(main(command))
